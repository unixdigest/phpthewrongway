<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="The Wrong Way">
  <title>PHP - The Wrong Way</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/css/html.css">
<meta name="description" content="このウェブサイトは、PHP プログラミングに関する現実的な見解を提示するために作成されたものです。流行りのトレンド、理論、学問的教示ではなく、経験と実践の帰着によって書き記された視点。">
</head>
<body>
<header>
<div id="header-top">
<a href="https://github.com/unixsheikh/phpthewrongway"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="/img/github-clone.png"></a>
<h1>PHP</h1>
<h2>The Wrong Way</h2>
<div id="date">最終更新日: 2019-03-03</div>
</div>
</header>
<div id="cartoon">
<img src="/img/deviant-code-1000px-ja.png" alt="cartoon">
</div>
<nav id="TOC">
<ul>
<li><a href="#概要">概要</a><ul>
<li><a href="#翻訳">翻訳</a></li>
</ul></li>
<li><a href="#過激主義の危険性">過激主義の危険性</a></li>
<li><a href="#常にフレームワークを使うこと">常にフレームワークを使うこと</a></li>
<li><a href="#常にデザインパターンを使用すること">常にデザインパターンを使用すること</a></li>
<li><a href="#常にオブジェクト指向プログラミングを使うこと">常にオブジェクト指向プログラミングを使うこと</a><ul>
<li><a href="#ちょっと歴史の授業">ちょっと歴史の授業</a></li>
</ul></li>
<li><a href="#他人のコードを恐れること">他人のコードを恐れること</a></li>
<li><a href="#宗教的に-php-fig-標準に従うこと">宗教的に PHP-FIG 標準に従うこと</a></li>
<li><a href="#セキュリティをサボる">セキュリティをサボる</a><ul>
<li><a href="#デフォルトで安全に">デフォルトで安全に</a></li>
</ul></li>
<li><a href="#faq">FAQ</a></li>
<li><a href="#お勧めの読み物">お勧めの読み物</a></li>
<li><a href="#コントリビュートするには">コントリビュートするには</a></li>
</ul>
</nav>
<h1 id="概要">概要</h1>
<p>PHPプログラミングの世界では、ある一定のトレンドが「モダンPHP」として、一部の人によって (彼らの書籍やウェブサイト上で) 強烈に広められ、他のアプローチは、遅れていたり、愚かだったり、あるいは単に間違いだとみなされて、眉をひそめられています。</p>
<p>それらの人々は、彼らの物事のやり方を他人に追従させようと、飽くなき努力を続けているように見えます。</p>
<p>このウェブサイトは、PHP プログラミングに関する現実的な見解を示すために作られました。流行りのトレンド、理論、学問的な教示ではなく、経験と実践の帰着を書き記した視点です。</p>
<p>ウェブサイト <a href="http://www.phpthewrongway.com/">PHP - The Wrong Way</a> は生きたドキュメントですので、より多くの情報が明らかになるにしたがって更新され続けます。</p>
<p>お気軽にコントリビュートしてください。</p>
<h2 id="翻訳">翻訳</h2>
<ul>
<li><a href="http://www.phpthewrongway.com/da/">ドイツ語</a></li>
<li><a href="http://www.phpthewrongway.com/">英語</a></li>
<li><a href="http://www.phpthewrongway.com/fr/">フランス語</a></li>
<li><a href="http://www.phpthewrongway.com/ja/">日本語</a></li>
<li><a href="http://www.phpthewrongway.com/fa/">ペルシャ語</a></li>
<li><a href="http://www.phpthewrongway.com/pt_br/">ポルトガル語</a></li>
<li><a href="http://www.phpthewrongway.com/ru/">ロシア語</a></li>
<li><a href="http://www.phpthewrongway.com/es/">スペイン語</a> <!-- todo: add French, Japanese and Turkish --></li>
</ul>
<h1 id="過激主義の危険性">過激主義の危険性</h1>
<p>プログラミングルールとガイドラインに関する問題のひとつに、それらがしばしば特定のコンテキスト内の目的にしか役に立たないことが挙げられます。コンテキストから逸脱すると、良いルールは恐ろしいルールになりえます。じっさいに、すべての良いルールは行き過ぎると悪いものになります。</p>
<p>なぜかを理解するうえで重要なのは、時間の経過とともに開発され、多くの異なる人々によって提示されたソフトウェア開発の原則やルールの大多数は、しばしば過激派の手によって誤用されたということです。</p>
<p>一般的なルールやガイドラインの誤用はつねに、合併症、セキュリティの欠如、エラーの発生しやすさ、場合によっては、完全かつ純然たる災害をもたらすと、経験が教えています。</p>
<p>“Keep It Simple, Stupid” の頭文字である <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS 原則</a> は、非常に賢明で優れた原則であり、一般に経験豊かな人々が従うべき非常に良いアドバイスとみなされますが、この大きな原則さえも、極端に取られるとプロジェクトにとって危険です。「あまりの単純さ」は、必要な機能の不足をもたらすことがあります。</p>
<p><strong>間違った方法</strong>: ルールとガイドラインの宗教的な遵守。 <img src="/img/thumbs-down.png" alt="だめ" /></p>
<h1 id="常にフレームワークを使うこと">常にフレームワークを使うこと</h1>
<blockquote>
<p>すべての汎用 PHP フレームワークはクソ!</p>
<p>– <a href="https://www.youtube.com/watch?v=DuB6UjEsY_Y">ラスマス・ラードフ</a></p>
</blockquote>
<p>PHP コミュニティにおいて、実に良くないトレンドが、Web アプリケーションを開発するためのデファクトスタンダードになってしまいました。流行っている汎用フレームワークを使う方法です。</p>
<p>このトレンドは、それがとにかく開発プロセスの結果を向上させるからでも、技術と構造的視点から行うことが正しいからでもありません。このトレンドが大衆化したのは、いくらかのフレームワーク開発者が、「車輪の再発明をするな!」「自分でするな、他者のほうがあなたより熟練している!」といったお決まりの文句に立脚して、プログラミングを論じる輩の排除に成功したためです。</p>
<p>今日のプログラマの多くは、健全なプログラミングの基本原則を完全に無視し、彼らは、よりクレバーに、よりクールに、仲間とみなしたどんな人にもより受け入れやすく見えるよう、新たな複雑さの層を幻想的にするがために多くの時間を費やしています。</p>
<p>こういった人々は、他の人が自分たちの「やり方」に従うこと、PHP コミュニティのリーダーか何かになること、そして彼らの最新版の「イケてる」オープンソースツールを他の人に使ってもらうことに夢中になり、彼らが提供している助言が健全かつ堅実であるか確かめるのを忘れているようです。</p>
<p>ソフトウェア業界では、汎用フレームワークを、建造済みの家で比喩することができます。建造済みの家をまとめるだけでは大工になれないように、汎用フレームワークを使ってソフトウェアを構築しても、コーダーやプログラマーにはなれません。</p>
<p>このウェブサイトでは、フレームワークとライブラリを次のように区別します:</p>
<ul>
<li>ライブラリは、C 標準ライブラリや Go 標準ライブラリのような、再利用可能なコードの集合と見なされます。それは、上限や制約を何ら強制することなく、あなた自身のプロジェクトに簡単に統合できるコードで構成されています。それは、単一の特定機能を備えた、小さなコードで構成されます。</li>
<li>フレームワークは単なる再利用可能なコードの集合ではありません、つまり、単純にフレームワークからコードを取り出して自分のプロジェクトに統合する、といったことはできません。フレームワークとは、ソフトウェアを構築するのに役立つシステムですが、同時に、フレームワーク自体の上限や制約の範囲内で作業するように強制します。フレームワーク自体には多くの相互依存を持つ機能があります。いっぽうは、他方がなければ機能しません。</li>
</ul>
<p>Python と Ruby の世界では、当初から Python も Ruby もウェブサイトを構築するために作られていなかったため、ウェブサイトを構築するのは面倒でした。その結果、<a href="https://en.wikipedia.org/wiki/Django_%28web_framework%29">Django</a> や <a href="https://en.wikipedia.org/wiki/Ruby_on_Rails">Ruby on Rails</a> などの汎用フレームワークが、これらの言語でウェブサイトを構築するために急速に普及しました。</p>
<p>いっぽう PHP は当初から、ラスマス・ラードフによって C 言語で書かれた一連のツールとして、動的 HTML を簡単かつ迅速に開発してもらえるようにと作成されました。今なおそうなのですが、そのような PHP は、<strong>それ自体がフレームワーク</strong> でした。</p>
<p>PHP はそれからずいぶん進化していて、今日、PHP は HTML やウェブサイトを構築する以外にも使用できるとはいえ、PHP 自体を一種のフレームワークとみなすことは間違いではありません。PHP は生まれつき、もっぱら手続き型の C 言語で書かれていた Web アプリケーション開発のための抽象化層です。</p>
<p>プロジェクト内でライブラリを使用するのは当然です。PHP 自体には、独自のコードを拡張するために使用できる一連のライブラリがバンドルされています。例えば、PDO は PHP でデータベースにアクセスするための一貫したインターフェースを提供する軽量ライブラリです。</p>
<p>それに対して PHP の上でフレームワークを使用することは、まったく別の問題です。</p>
<p>PHP でフレームワークを使用すると、抽象レイヤーを別の抽象レイヤーの上に追加してしまいます。一方は最初から使えるよう用意されているのに。フレームワークから提供される抽象概念の追加レイヤーが与えてくれるのは、コードをあらかじめ決められた一定のパターンに編成することか、あるいは、何百何千ものクラスとメソッドを依存関係の悪夢に絡み合わせて過剰な複雑さを追加することか、どちらにしても、コードに複雑なレイヤーを追加することになり、不要です!</p>
<p>すべての経験はインターフェースから始まります。インターフェースの経験は、基盤技術と抽象レイヤの量の結果です。使用した抽象が多くなれば、インターフェースの効率が低下し、アプリケーションはエラーが発生しやすくなります。抽象度が高いほど、詳細と効率が失われます。</p>
<p>はっきりと理解すること: <strong>どんなプロジェクトでも、コードの理想は、可能な限り少ない行数で、可能な限り明確かつ可読であること!</strong></p>
<blockquote>
<p>誰も必要としていないのは、万能なフレームワークです。みんながみんな一般的な問題を抱えているわけではなく、みな非常に特殊な問題を抱え解決しようと試みています。</p>
<p>– <a href="https://www.youtube.com/watch?v=anr7DQnMMs0">ラスマス・ラードフ</a></p>
</blockquote>
<p>ある企業は、PHP フレームワークに関する誇大宣伝を耳にして、そういった流行っている汎用フレームワークのひとつを使って次のプロジェクトを開始しましたが、災害に終わっただけでした。汎用フレームワークは、彼らの非常に特別なニーズを解決するにあたって本当に悪いものだと発見しただけでなく、それは稼働中も究極的に遅かったのです。スケール不可能で、その結果、彼らは本当に必要のないものすべてを抜き出すために、絶望的な試みのなか、フレームワークを切断分割し始めました。</p>
<p>常に実用的なアプローチを使用すること:</p>
<blockquote>
<p>行動や方針は、理論や教義ではなく、直接的な実践的結果を考慮して、決定される。</p>
<p>– コリンズ英語辞典, Complete and Unabridged, 第 12 版 2014</p>
</blockquote>
<p><strong>間違った方法</strong>: PHP 上で常にフレームワークを使うこと。 <img src="/img/thumbs-down.png" alt="だめ" /></p>
<h1 id="常にデザインパターンを使用すること">常にデザインパターンを使用すること</h1>
<blockquote>
<p>私には、象牙の塔のデザインとデザインパターンへの、強いアレルギーがあります。ピーター・ノーヴィグは、ハーレクインにいたとき、デザインパターンが現実にはプログラム言語の欠陥であるという点に関して、論文を出しました。より良いプログラミング言語を手に入れましょう。彼は絶対に正しい。パターンの崇拝、「ああ、私はパターン X を使います」の考察。</p>
<p>– ブレンダン・アイク <a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
</blockquote>
<p>ソフトウェア・エンジニアリングでは、デザインパターンは、ソフトウェア設計における一般的な問題に対する、再利用可能なソリューションです。 デザインパターンは、コードに直接変換できる最終設計ではありません。これは、さまざまな状況で使用できる、問題を解決する方法の説明またはアイデアです。オブジェクト指向のデザインパターンは、通常、関連する最終アプリケーションクラスまたはオブジェクトを決定づけるのではなく、クラスまたはオブジェクト間の関係および相互作用を示します。</p>
<p>PHP は、命令型、関数型、オブジェクト指向、手続き型、およびリフレクティブなパラダイムをサポートしています。PHP は、さまざまな方法で多くの問題を解決することを可能とする、異種混合なツールを備えた巨大な道具箱です。</p>
<p>PHPはすべて自由で、高速でスケーラブルなソリューションであり、さまざまな方法で問題を処理します。</p>
<p>私たちは、自身を改善しようとすると、この場合具体的にはコードをですが、ときどき、特定のパターンの哲学や思想に縛られ、実際に考えることを忘れる傾向があります。</p>
<blockquote>
<p>私は、自分のプログラムでパターンを見かけると、それを不具合の兆候と考えます。プログラムの形は、解決の必要がある問題のみを反映するべきです。コードにあるその他の規則性は、少なくとも私には、自分が不十分で貧弱な抽象を使用していることを示すサインで、私はよく、記述しないといけないマクロの拡張を手作業で生成しています。</p>
<p>– <a href="http://c2.com/cgi/wiki?AreDesignPatternsMissingLanguageFeatures">ポール・グレアム</a></p>
</blockquote>
<p>特定のパターンやソリューションの背後にある哲学や思想を、キャッチアップする必要はありません。私たちの主な関心事は、コードを、可能な限りナビゲートしやすくかつ理解しやすく保ち、その結果、保守が容易で安全性を保ちやすくすることです。</p>
<p>私たちはまた、アンチパターンのようなものが存在することを覚えておく必要があります。これは、一般的に使用されうるけれども、実際には効果的でなく、かつ/または非生産的であるパターンのことです。</p>
<blockquote>
<p>私は、パターンとは、一般的に認識された最適な解決策として、共通した問題のために始まったと思います。しかし、しばらく彼らの側にいたところ、人々が自分の読んだことがあるすべてのパターンを詰め込もうとしたために (「私のアプリケーションはよく構成されているぞ、なぜならパターンをともなってアゴの贅肉にロードされるからな」) アプリケーションがあるべき姿の 10 倍以上複雑になってしまった経験があって、パターンの価値について、私の印象は少し下がりました。</p>
<p>– ポール・ウィートン <a href="http://www.javaranch.com/patterns/">Evil Design Patterns</a></p>
</blockquote>
<p>常に実用的なアプローチを使用すること:</p>
<blockquote>
<p>行動や方針は、理論や教義ではなく、直接的な実践的結果を考慮して、決定される。</p>
<p>– コリンズ英語辞典, Complete and Unabridged, 第 12 版 2014</p>
</blockquote>
<p><strong>間違った方法</strong>: 問題を解決できるパターンを探すこと。 <img src="/img/thumbs-down.png" alt="だめ" /></p>
<h1 id="常にオブジェクト指向プログラミングを使うこと">常にオブジェクト指向プログラミングを使うこと</h1>
<blockquote>
<p>オブジェクト指向言語の問題は、これらの暗黙の環境をすべて持ち歩いていることです。あなたはバナナを欲しましたが、あなたが得たものはバナナを抱えたゴリラとジャングル全体でした。</p>
<p>– ジョー・アームストロング in <a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
</blockquote>
<blockquote>
<p>抽象化は強力ですね。私が本当にアレルギーを持つもの、そして 90 年代に反応したのは、ありとあらゆる CORBA、COM、DCOM、オブジェクト指向ナンセンスでした。当時のスタートアップには、起動して “Hello world” を印刷するために 200,000 回のメソッド呼び出しが必要だといった、なんだか狂ったことがありました。残念です! その種のことに関わるプログラマーになりたくはないですよね。</p>
<p>– ブレンダン・アイク in <a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
</blockquote>
<p>今日、多くのソフトウェア開発者や多くの企業は、オブジェクト指向プログラミングだけが、ソフトウェアを開発する合理的な方法だと感じています。オブジェクト指向プログラミングに反対する人は、彼らが業界の「伝統的な知性」に反対しているんじゃないかと、すぐに萎縮してしまいます。</p>
<p>プログラミングのブログやフォーラムでは、とても多くの人がオブジェクト指向プログラミングを擁護し、何について話しているか自分でわかっていると確信しています。標準の定義が不足しているにもかかわらずですよ!</p>
<p>実際のところ、オブジェクト指向プログラミングと呼ばれるようなものは、しばしば不必要な複雑さの重い負担を強います。</p>
<p>コンピュータ科学者やプログラマとして、私たちは、こだわりを脇において、与えられた問題に対する最良の解決策を見つける、ということを学ぶ必要があります。</p>
<p>今日、PHP の主な強みのひとつは、命令型、関数型、オブジェクト指向、手続き型、およびリフレクティブの全パラダイムのサポートです。PHP はさまざまなツールを備えた巨大なツールボックスであり、さまざまな方法で多くの問題を解決することができます - <strong>たったひとつの方法ではなく!</strong></p>
<p><strong>アプリケーション内のさまざまな問題を単一の特定のプログラミングパラダイムに強制しようとすると、あっという間に、私たちは創造的に思考しなくなり、効率的に作業しなくなります !</strong></p>
<h2 id="ちょっと歴史の授業">ちょっと歴史の授業</h2>
<p>特定のプログラミングパラダイムを理解するのに良い方法のひとつは、それが最初にどのように進化したかに着目することです。その開発の理由は何? 新しい考え方が必要だった他のプログラミングパラダイムには、どんな問題があった? それは現実世界の問題か単に学問的な問題だったか? そして以来どのように進化してきたか?</p>
<p>X という人が何を言っているのか、Y という人が何を定義しているのかは関係ありません。パラダイムの中で重要なのは、それらを作った歴史です。</p>
<blockquote>
<p>ソフトウェア設計を構築するには、2 つの方法があります。ひとつの方法は、シンプルにすることで、明らかに欠点がないようにすることです。そしてもう一つの方法は、非常に複雑にして、明らかな欠陥がないようにすることです。</p>
<p>– <a href="https://en.wikiquote.org/wiki/C._A._R._Hoare">C.A.R. ホーア</a></p>
</blockquote>
<p>かつて、オブジェクト指向プログラミングの登場以前、50 年代の終わり頃、多くのソフトウェアは、第 1 世代および第 2 世代の言語と呼ばれる、しいて言えば非構造化プログラミングと言われるプログラミング言語を使用して、開発されました。非構造化プログラミング (または構造化なしプログラミング) は、歴史上最も初期のプログラミングパラダイムです。それは「スパゲッティ」コードを作成すると強く批判されました。</p>
<p>非構造化プログラミングを使用する言語には、高レベルなものも低レベルなものもあります。これらには、初期バージョンの BASIC、COBOL、MUMPS、JOSS、FOCAL、TELCOMP、機械語、初期アセンブラシステム (プロシージャー疑似命令のないもの)、およびいくらかのスクリプト言語が含まれます。</p>
<p>非構造化言語のプログラムは、通常は各行に1つずつの順番に並んだ命令あるいはステートメントで、通常構成されます。行は通常、番号付けされるかラベルを持ち、実行フローがプログラム内の任意の行に (不人気な GOTO 文のように) ジャンプできるようになっています。</p>
<p>そして、60 年代には、構造化プログラミングが浮上しました - 主に、エドガー・W・ダイクストラ の有名な手紙 <a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">Go To statements considered harmful</a> のおかげで。</p>
<p>後に、手続き型プログラミングが構造化プログラミングから派生しました。手続き型プログラミングは「プロシージャ呼び出し」という概念に基づいています。「プロシージャ呼び出し」は、単に「関数呼び出し」の別名です。プロシージャは、ルーチン、サブルーチンまたはメソッドとも呼ばれます。プロシージャは、一連の計算ステップを含んでいるにすぎません。定義された任意のプロシージャは、他のプロシージャまたはそれ自体を含み、プログラムの実行中の任意の時点で呼び出されます。</p>
<p>最初は、すべてのプロシージャがプログラムのどの部分でもグローバルデータとして利用可能でした。これは小さなプログラムでは問題はありませんが、状況が複雑になり、プログラムのサイズが成長すると、プログラムの一部の小さな変更が、他の多くの部分に大きく影響しました。</p>
<p>誰もプログラムの変更を計画しておらず、多くの依存関係が存在していました。ひとつのプロシージャへの小さな変更が、元のコードに依存する他の多くのプロシージャで、エラーのカスケードを発生させます。</p>
<p>新しい技術は、データを「オブジェクト」と呼ばれる分離したスコープに分割することができるよう進化させました。同じスコープに属する特定のプロシージャだけが同じデータにアクセスできます。これは、データ隠蔽またはカプセル化と呼ばれます。その結果、より整理されたコードが得られました。</p>
<p>最初はオブジェクトがオブジェクトと呼ばれず、それらは別のスコープと見られました。後で依存関係が縮小され、これらのスコープ内のプロシージャーと変数の間の接続が分離されたセグメントと見られるようになって、その結果が「オブジェクト」および「オブジェクト指向プログラミング」という概念を生み出しました。</p>
<p>後に、主に Java の開発のために、ある「バズワード」が発生し、「プロシージャ」または「関数」はもはや関数と呼ばれなくなり、分離スコープ内に存在するときは「メソッド」に改名されました。変数はもはや「変数」と呼ばれなくなり、分離スコープ内に存在するときは「属性」に名前が変更されました。</p>
<p>なので、オブジェクトは本質的に、単なる関数と変数の集合が現在「メソッドと属性」と呼ばれるようになっただけです。</p>
<p>メソッドと属性を分離スコープの中に隔離して保持する方法とは、「クラス」を使うことです。クラスは、インスタンス化されると、オブジェクトと呼ばれます。</p>
<p>オブジェクトはお互いを参照することができ、そのような参照によって、中にあるメソッド (関数) は互いに「通信」することができます。オブジェクトは他のオブジェクトからメソッドを「継承して」拡張することもでき、これは「インヘリタンス」と呼ばれます。これは、コードを再利用し、パブリッククラスとインタフェースを介して、ソフトウェアの独立した拡張を可能にする方法です。オブジェクトの関係によって階層が生じます。継承は 1967 年にプログラミング言語 <a href="http://en.wikipedia.org/wiki/Simula">Simula 67</a> のために発明されました。</p>
<p>オブジェクトは、他のオブジェクトからメソッドを継承し、追加または変更された機能でこれらを「オーバーライド」することもできます。これは「ポリモーフィズム」と呼ばれます。</p>
<p>これらのさまざまなアイデアがどのように実装されているかは、プログラミング言語のピンからキリまでで大きく異なります。</p>
<p>オブジェクト指向プログラミングとは、これまでとは別の方法でコードを整理することです。それは手続き型プログラミングの拡張であり、データの隠蔽 (カプセル化) とグローバルスコープを回避することです。実際には元のコードに影響を与えずに青写真の「借用」によって機能を拡張すること (インヘリタンス) です。そして、元のコードに影響を与えずに関数をオーバーライドすること (ポリモーフィズム) です。</p>
<blockquote>
<p>オブジェクト指向モデルは付け加えによってプログラムの構築を簡単にします。実際には、多くの場合、スパゲッティコードを書くための構造的手法を提供するという意味なのですが。</p>
<p>– ポール・グレアム in <a href="https://openlibrary.org/works/OL7944696W/ANSI_Common_Lisp">Ansi Common Lisp</a></p>
</blockquote>
<p><strong>間違った方法</strong>: 常にオブジェクト指向プログラミングを使うこと。 <img src="/img/thumbs-down.png" alt="だめ" /></p>
<h1 id="他人のコードを恐れること">他人のコードを恐れること</h1>
<p>フレームワークの使い方についてしばしば表明される議論は、他人がスクラッチで書いたコードベースを扱いたいとは思う人はいない、ということです。</p>
<p>しかし、これは奇妙な考え方で、主に PHP コミュニティの Web 開発者が遭遇します。それはプロフェッショナリズムと経験の不足を滲出させるものです。</p>
<p>ソフトウェアを書くことと他人のコードを扱うことは普通のことです。それはプロのプログラマーの毎日の仕事の一部です。恐れるべきことではありません。</p>
<p>プロのプログラマーで他人のコードを見ない者は、もう会社やプロジェクトに在籍していないであろう前任のプログラマーの完全な慈悲にどうやってすがろうか、そして以前のプログラマーがフレームワーク A またはフレームワーク B を使っていたら人日が節約できたのにと、泣き言を言いだします。</p>
<p>これはプロのプログラマーのメンタリティではありません。こんなこと誰もしません。</p>
<p>おそらく、PHP の Web 開発の参入障壁の低さが、この種のメンタリティの一部にひと役買っています。そんなこと関係ありません、それは間違った作業ラインにいる人の兆候です。</p>
<p>プログラミングの大部分は、他人のコードで仕事する必要がある人を扱います。既存のコードベースの改善に挑むことは、時には完全なリライトでの改善となっても、仕事の一部です。</p>
<p>プログラミングの偉大な巨匠に習いましょう、<a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a> という本を読んでください。</p>
<p>世界で最も大きく成功したコードベースのいくつかは、お互いに会ったことのない何百人もの人々によって開発されたコードベース、あらゆる種類のフレームワークを使用せずに開発されたコードベース、手続き型パラダイム以外のものを使わずに完全に手続き型プログラミング言語で行われたコードベース、であり、それが違ったやり方をすることを夢見るなんてことはありません。</p>
<p><a href="https://www.kernel.org/">Linux カーネル</a> は、あらゆる種類のフレームワークを使用せずに14,000 人以上の参加者によって、すべて手続き型プログラミングを使用して書かれた 2,000 万行以上のコードで構成されています。</p>
<p>さまざまな <a href="https://en.wikipedia.org/wiki/Berkeley_Software_Distribution">BSD</a> フレーバーと <a href="https://www.gnu.org/">Linux GNU ユーザランド</a> のほとんどは、あらゆる種類のフレームワークを使用せずに、すべて手続き型プログラミングを使用して書かれています。</p>
<p>元のプログラマーに最終的に放棄された、世界中の何百ものオープンソースプロジェクトは、他の熟練したプログラマーに拾われています。これらのプロジェクトの多くには、ごくわずかなドキュメント (もしあるなら) しかなく、コードベースにはコメントがなく、ガイドラインやヘルプも提供されていませんでした。</p>
<p>PHP のコードベース全体は、純粋な手続き型プログラミング言語である C 言語で行われ、フレームワークをまったく使用することはありません。</p>
<p>PHP でクラスを定義するたび、お気に入りの PHP フレームワークを起動するたびに、他の誰かの純粋な手続き型の作業を実行しているのです!</p>
<p>確かに、恐ろしいコード、おそらくはじめから設計されていなかったコード、またはクライアントが書き直しを選択したくなくて何度も自己成長しているであろうコード、といったものは存在し、コードが悪すぎてもうあなたには手に負えないとしても、どんなフレームワークもこのような状況を防いでくれはしません。これはよくあるプログラムの自然な成長プロセスです。とにかく、どんな種類のフレームワークも結局は断片化してしまいます。</p>
<p>恐ろしいスパゲッティコードが存在することは確かですが、誰も恐ろしいスパゲッティコードを意図的に作りはしません。場合によっては経験不足の結果かもしれませんし、クライアントのせいで開発の途中で何度か仕様を変更したというのはしょっちゅうですが、その両方のいずれの場合でも、フレームワークを使用したところで結果はスパゲッティコードになります。また、どれだけオブジェクト指向のパラダイムが使用されても、結果はやはりスパゲッティコードになります。</p>
<p>プログラマとして、私たちがみな回避しようとするこのような状況ですが、<strong>これは普通のことで</strong>、これは <strong>プログラミングの芸術</strong> で、これは <strong>プログラマであること</strong> が意味するもののひとつなのです!</p>
<p><strong>間違った方法</strong>: 他人のコードを恐れること。 <img src="/img/thumbs-down.png" alt="だめ" /></p>
<h1 id="宗教的に-php-fig-標準に従うこと">宗教的に PHP-FIG 標準に従うこと</h1>
<p>FIG とは「フレームワーク相互運用性グループ」のことです。</p>
<p><a href="http://www.php-fig.org/">PHP-FIG</a> は、2009 年に php|tek の多数のフレームワーク開発者によって作成されました。それ以来、様々な他のメンバーが応募して採択され、グループのサイズを最初の 5 から 20 以上に増やしました。</p>
<p>PHP-FIG に関しては多くの論争が存在します。一部の人々は、PHP そのものに由来して PHP コミュニティに起こった最善のことと考えていますが、他は最善の何かを忘れてしまったグループとみなしています。</p>
<p>PHP-FIG にまつわる問題のひとつは、彼らの <a href="http://www.php-fig.org/faqs/">FAQ</a> にあるこの部分のように自己紹介していることです:</p>
<blockquote>
<p>グループの背後にある発想は、プロジェクト代表者たちが、プロジェクト間の共通点について話し合って、共同で作業する方法を見つけることです。私たちの主なオーディエンスはお互いですが、残りの PHP コミュニティが見ていることはとても意識しています。他の人々が私たちがやっていることを採用したいなら、やるのは歓迎ですが、採用してもらうことが目的というわけではありません。グループの誰も、プログラマーとして、あなたのアプリケーションを構築する方法を教えたいとは思っていません。</p>
</blockquote>
<p>しかし、グループのいくつかのメンバーの作業を見ると、その目的が上記の宣言とはまったく反対であることが明確に分かります。これらのメンバーは、PHP-FIG が、<strong>このグループのもともとの名称でもある</strong> 信頼された「PHP 標準グループ」になるよう、飽くなき努力をしています。彼らのやりかたは、自分の書籍、ウェブサイト、ブログ投稿、フォーラムなどで PHP-FIG の作業を「モダン PHP」と分類し、他の方法を逆に分類することです。</p>
<p>PHP-FIG にまつわる問題のひとつは、多くのフレームワークとオープンソースプロジェクトがいくつかの標準を採用しているにもかかわらず、これらの標準は主に「フレームワークの視点」からの問題に対処しているため、多くの現実の業界の状況で実に使いづらくなっています。</p>
<p>多くの人々が、非常に効率的で、安全で、費用対効果の高い、顧客が購入して使いたいと思うような、産業向けのソフトウェアを開発しています。彼らは、フレームワーク狂信者のニーズに合致するべきだという標準に悩まされることはありません。彼らがそうしようとすると、ビジネスの災害になるでしょう。</p>
<p>何らかの標準グループを作成する必要がある場合、フレームワークとオープンソースの CMS プロジェクト開発者だけでなく、PHP コミュニティ全体の利益を反映する必要があります。それは、PHP プログラミング言語そのものの開発者によって表されなければならず、投票権を持つはるかに大きなメンバーシップによって表明されなければなりません。</p>
<p>PHP-FIG によって開発された標準 - オートローダー標準 PSR-0 と PSR-4 およびその他標準のいくつか - を採用すると選択した場合、あなたがソフトウェアをどうコーディングするかに直接影響します。</p>
<p>多くの産業で求められる、スケーラビリティがあり、ランタイムクリティカルで、コスト効率の高いソフトウェアは、単純に言って、これらの PHP-FIG の標準を使用して開発することはできません。</p>
<p><strong>間違った方法</strong>: 宗教的に PHP-FIG に従うこと。 <img src="/img/thumbs-down.png" alt="だめ" /></p>
<h1 id="セキュリティをサボる">セキュリティをサボる</h1>
<blockquote>
<p>プログラマーにまつわるトラブルとは、手遅れになるまで、プログラマーが何をしているのかを決して伝えないことです。</p>
<p>– シーモア・クレイ on <a href="http://www.defprogramming.com/q/6e61ae30a855/">defprogramming.com</a></p>
</blockquote>
<p>セキュアコーディングは、悪意や意地悪心のある人、他のプログラムによる攻撃に対して、耐性のあるプログラムを書くことです。セキュアコーディングは、盗難や破損からデータを保護するのに役立ちます。さらに、安全でないプログラムは、攻撃者にサーバーの制御やユーザーの身元情報の取得へのアクセスを提供し、サービス妨害(DoS)から単ユーザーまでのあらゆるもので、情報漏えい、サービスダウン、または数千人のユーザーのシステムへのダメージまでをもたらします。</p>
<p>すべてのコンピュータプログラムは、セキュリティ攻撃の可能性のあるターゲットです。攻撃者は、アプリケーションのセキュリティ上の脆弱性を発見しようとします。彼らは、これらの脆弱性を利用して秘密を盗み、プログラムやデータを破壊し、サーバーやネットワークを制御しようとします。あなたの顧客の財産とあなたの評判は危険にさらされています。</p>
<p><strong>セキュリティはソフトウェアに後付けできる何かではありません!</strong></p>
<p>安全でないアプリケーションでは、セキュリティを確保するために大幅な再設計が必要になることがあります。ソフトウェアの脅威の本質を特定し、アプリケーションの計画と開発の最初から、セキュアコーディングのプラクティスを組み込む必要があります。</p>
<p>攻撃者の関心が着実にアプリケーション層に向かっているため、重要なソフトウェアリソースをセキュアにすることは、かつてないほど重要です。2009 年の SANS 調査によると、Web アプリケーションに対する攻撃は、インターネット上で観測された攻撃の合計攻撃の 60% 以上を占めています。</p>
<p>PHP は、プログラミング言語でもあり Web フレームワークでもあるという点で、ちょっと変わっています。つまり PHP には、言語に組み込まれた多くの Web 機能があって、安全でないコードを書くのが非常に簡単なのです。</p>
<h2 id="デフォルトで安全に">デフォルトで安全に</h2>
<blockquote>
<p>複雑さが殺す。それは開発者から命を吸い取り、製品の計画、構築、テストを難しくし、セキュリティ上の課題を生じさせ、エンドユーザーや管理者の不満を生みます。</p>
<p>– <a href="www.azquotes.com/quote/585933">レイ・オジー</a></p>
</blockquote>
<p>アプリケーションが適切なセキュリティ要件で設計/実装されるようにするには、セキュアコーディングのプラクティスとセキュリティリスクへの集中を、日々の運用、思想、開発プロセス自体に、統合する必要があります。</p>
<p>一般に、ソフトウェアパッケージが完成した後にセキュリティ問題を修正するよりも、安全なソフトウェアを構築する方がはるかに安価です。セキュリティ違反と付き合うコストは言うまでもありません。</p>
<p><strong>間違った方法</strong>: デフォルトで安全なソフトウェアを開発しないこと。 <img src="/img/thumbs-down.png" alt="だめ" /></p>
<h1 id="faq">FAQ</h1>
<p>記述された文書は誤解されやすいのでいくつかの問題を明確にしましょう。</p>
<p><strong>Q:</strong> <em>このサイトのポイントは何ですか? なぜ対立的なアプローチなのですか?</em></p>
<p><strong>A:</strong> 議論を作り、現在のプラクティスと極端な視点について考えるためです。</p>
<p><strong>Q:</strong> <em>あなたはオブジェクト指向プログラミングが悪いとか間違っているとか言っていますか?</em></p>
<p><strong>A:</strong> いいえ、もちろん違います! 問題を解決するために、常にオブジェクト指向のパラダイムだけを考慮し使用することが、悪だと言っています。白か黒かだけで考えると、それは間違っています。</p>
<p>単一のアプリケーション内であっても、異なる問題が存在します。マルチパラダイムが最適な解決策になることもあり、それはすべて、あなたが解決しようとしている問題によります。</p>
<p>特定の問題を不適切な解決策に強制的に送り込むと、かならず悪いことが起こります。</p>
<p><strong>Q:</strong> <em>すべてのフレームワークが悪だと言っているのですか?</em></p>
<p><strong>A:</strong> 特定のフレームワークを判断しようとしているわけではありません。私たちは PHP 上で常にフレームワークを使用することの問題を扱っています。</p>
<p><strong>Q:</strong> <em>フレームワークでさっさとやってすぐ動かせるのなら、どうしてそんなに悪いのですか?</em></p>
<p><strong>A:</strong> 状況や長期的な影響を分析して、「さっさとやってすぐ実行」が、あなたが対処しなければならない唯一の問題であることがわかったのなら悪くないですが、我々はプログラミングやソフトウェア開発を重点的に扱っていて、我々はだいたいポイントアンドクリックソリューションを扱っています。</p>
<p>さっさとやってすぐに実行することは、ソフトウェアを設計することではなく、あなたが直面している問題を分析しておらず、あなたが選択したことの長期的な意味を理解していないということです。</p>
<p><strong>Q:</strong> <em>サードパーティのパッケージは悪だと言っていますか?</em></p>
<p><strong>A:</strong> いいえ。サードパーティのライブラリの使用は促進しています。上限や制約を強制することなく、自分のプロジェクトに簡単に統合できるコード。それらは素晴らしいです!</p>
<p><strong>Q:</strong> <em>あんた誰?</em></p>
<p><strong>A:</strong> このウェブサイトは、PHP コミュニティの発想と過激化に対抗するものであり、個人的な名声や認識ではありません。人に名前を持たせると、ウェブサイト上に置かれた問題から、問題にまつわる人に焦点を移すだけです。発想に集中してください。</p>
<p><strong>Q:</strong> <em>ソフトウェア開発におけるあなたの経験は何ですか?</em></p>
<p><strong>A:</strong> 他人がそう言っているから常に何かあることをする、という主題に集中してもらえれば、このウェブサイトに掲載されている発想、思考、結論に至るのに経験はそれほど必要ありません。</p>
<h1 id="お勧めの読み物">お勧めの読み物</h1>
<p><a href="https://news.ycombinator.com/item?id=12318615">PHP The Wrong Way on Hacker News</a></p>
<ul>
<li>「PHP The Wrong Way」が発表されたとき、Hacker News に、一読に値する多くの貴重な議論を含んだ、たくさんのコメントが寄せられました。</li>
</ul>
<p><a href="https://news.ycombinator.com/item?id=12377385">Why bad scientific code beats code following “best practices”</a></p>
<ul>
<li>単純思考で気遣いのない近くの無能は、産業的に強く良い意図よりも、地獄への高速道路の舗装に適しています。コンピュータの外にある「現実の世界」はそのような例でいっぱいです。</li>
</ul>
<p><a href="https://medium.com/@brianwill/how-to-program-without-oop-74a46e0e47a3#.squpnjz4n">How to program without OOP</a></p>
<ul>
<li>新鮮で代替的な視点として、Brian Willは、3つのビデオで、オブジェクト指向プログラミングがなぜ悪いアイデアなのかを説明し、どのように非 OOP コードを記述するべきか、いくつかのノートでシリーズを完成させます。</li>
</ul>
<p><a href="http://codersatwork.com/">Coders at work - Reflections on the Craft of Programming</a></p>
<ul>
<li>Coders at Work の Q＆A インタビューでは、15 人の常勤プログラマーやコンピュータ科学者との約 80 時間の会話を基に、プログラマーがどのようにプログラムを学び、どのようにクラフトを実践し、プログラミングの将来について考えるかについて、多面的な視点を提供しています。</li>
</ul>
<p><a href="https://www.oreilly.com/ideas/the-traits-of-a-proficient-programmer">The traits of a proficient programmer</a></p>
<ul>
<li>技量とは、十分な経験と知識を持っていることを意味します。熟練とは、なぜあなたが特定の形でやっているのか、どのようにビッグ・ピクチャーに適合しているのかを、知ることに関わります。言い換えれば、熟練した開業医は常に有能な開業医ですが、その逆は真でないかもしれません。</li>
</ul>
<p><a href="https://www.owasp.org/images/0/08/OWASP_SCP_Quick_Reference_Guide_v2.pdf">OWASP Secure Coding Guidelines</a></p>
<ul>
<li>このテクノロジーにとらわれない文書では、チェックリスト形式で、ソフトウェア開発のライフサイクルに統合させることができる、ひととおりの一般的なソフトウェアセキュリティ・コーディングのプラクティスを定義します。これらのプラクティスの実装は、最も一般的なソフトウェアの脆弱性を緩和します。</li>
</ul>
<p><a href="https://www.owasp.org/index.php/Security_by_Design_Principles">Security by Design Principles</a></p>
<ul>
<li>Web アプリケーションのセキュリティは、オープンソースの PHP アプリケーション、ストレートスルー処理のような Web サービス、またはプロプライエタリなビジネス Web サイトなど、成功するプロジェクトにとって不可欠な部品です。ホスティング業者は (厳密に) 安全でないコードを避け、ユーザーは詐欺につながる安全でないサービスを避けます。この開発ガイドの目的は、企業、開発者、設計者、およびソリューション設計者が安全な Web アプリケーションを作成できるようにすることです。最初期段階から実行された場合、安全なアプリケーションは、安全でないアプリケーションと同程度の開発コストになりますが、長期的には、はるかにコスト効率に優れています。</li>
</ul>
<p><a href="http://phpsecurity.readthedocs.io/en/latest/">Survive The Deep End: PHP Security</a></p>
<ul>
<li>重大なセキュリティ違反のすべてのターゲットは、プレスリリースやウェブサイトですぐに知られます。セキュリティは非常に重要であり、非常に真剣に受け止めましょう。頑張ってそれを学ぶ前に、この感情を心に抱くことが推奨されます。</li>
</ul>
<p><a href="https://openlibrary.org/books/OL7407595M/Refactoring">Refactoring Improving the Design of Existing Code</a></p>
<ul>
<li>リファクタリングとは、既存のコードの設計を改善することです。これは、コードの外部動作を変更せずに内部構造を改善する方法で、ソフトウェアシステムを変更するプロセスです。リファクタリングでは、悪い設計を取り出し、それを良いものに再加工することさえできます。この本では、リファクタリングの機会を見つける場所や、必要なテストの設定方法など、リファクタリングの原則について徹底的に説明しています。また、リファクタリングをいつ、どのように使用するか、それを実装するためのステップごとの説明、およびその動作の例を示す 40 以上の実績のあるリファクタリングのカタログがあります。この本は主な言語として Java を使用して書かれていますが、そのアイデアはどの OO 言語にも当てはまります。</li>
</ul>
<p><a href="https://openlibrary.org/works/OL15333872W/The_Practice_of_Programming_%28Addison-Wesley_Professional_Computing_Series%29">The Practice of Programming</a></p>
<ul>
<li>プログラマーの仕事にとって重要な実践的事項の概要。</li>
</ul>
<p><a href="https://openlibrary.org/works/OL5748544W/The_pragmatic_programmer">The pragmatic programmer</a></p>
<ul>
<li>Pragmatic Programmer：職人から匠まで、コアプログラミングプロセスを検証します。必要条件を満たすとともに、きちんと働いて保守可能な、ユーザーに喜んでもらえるコードを作成します。個人の責任とキャリア開発から、コードを柔軟に、適応しやすく、再利用可能に保つためのアーキテクチャー・テクニックまで、といったトピックをカバーしています。</li>
</ul>
<p><a href="https://openlibrary.org/works/OL1875800W/Understanding_programming_languages">Understanding programming languages</a></p>
<ul>
<li>プログラミング言語の選択は、ソフトウェアシステムの最終的な品質に影響を与える最も重要な要素のひとつです。残念なことに、言語スキルが劣ったプログラマーが多すぎます。彼らは熱心に「ネイティブ」言語を愛していますが、言語の制約を分析できません。「Understanding programming languages」は、言語設計者にどのような選択肢があるのかを説明する目的で書かれています。安全性と可読性の観点から言語構造をどのように使用すべきか、言語構造がどのように実装され、どれが効率的に遵守されるか、抽象概念を表現し強制する際の言語の役割は何か。</li>
</ul>
<h1 id="コントリビュートするには">コントリビュートするには</h1>
<p><a href="https://github.com/unixsheikh/phpthewrongway">GitHub</a> でコントリビュートします。</p>
<ul>
<li>クローンして編集してください。</li>
<li>検討のためにプルリクエストを提出してください。</li>
</ul>
<p><em>sections/LANGUAGE</em> にセクションを追加するか、既存のセクションを編集してください。</p>
</body>
</html>
